---
layout: post
tag: rust
---
***

### Stack

- 크기가 고정된 데이터가 저장되는 빠르고 효율적인 메모리 영역
- 스택은 컴파일 시점에 크기가 확정된 데이터만 저장할 수 있습니다. 이런 데이터는 보통 단순하고 고정된 크기를 가지며, 복사가 빠르다.

#### 특징
- 고정크기: 컴파일러가 데이터의 크기를 미리 알 수 있어야 한다.
- 빠른 접근: 스택은 LIFO구조로 관리되며, 메모리 할당/해제가 매우 빠르다.
- 암목적 복사 가능: `Copy`트레이트를 구현한 타입은 스택에서 비트 단위로 복사된다.
#### 예시
- 기본 타입: i32, u32, f64, bool, char 등.
- 고정 크기 배열: `[i32; 4]` (4개의 i32를 담은 배열).
- 튜플: (i32, bool) 등.

```rust
fn main() {
    let x: i32 = 42;  // 스택에 저장
    let y = x;        // 스택에서 비트 단위 복사 (Copy 트레이트)
    println!("x: {}, y: {}", x, y); // x: 42, y: 42
}
```
- i32는 4바이트로 고정된 크기라 스택에 저장됨.
- y = x는 소유권 이동이 아니라 값 복사(Copy)가 발생.


### Heap

- 크기가 동적인 데이터가 저장되는 유연한 메모리 영역
- 힙에 저장된 데이터는 포인터(스택에 저장)를 통해 접근되며, 복제 시 추가 작업이 필요하다.

#### 특징
- 동적 크기: 컴파일 시점에 크기를 알 수 없거나 가변적인 경우.
- 포인터 사용: 스택에 저장된 포인터(주소)가 힙 데이터를 가리킨다.
- 명시적 복제: 힙 데이터는 Clone 트레이트로 .clone()을 호출해야 복제된다.
- 메모리 관리: Rust의 소유권 시스템으로 할당/해제가 관리된다.

#### 예시
- String: 가변 길이 문자열. 스택에는 포인터, 길이, 용량이 저장되고, 실제 문자열 데이터는 힙에 저장.
- `Vec<T>`: 동적 배열. 요소들이 힙에 저장됨.
- `Box<T>`: 힙에 저장된 단일 값.
- 구조체/열거형: 내부에 String이나 Vec 같은 힙 데이터를 포함하면 일부가 힙에 저장.

```rust
fn main() {
    let s1: String = String::from("Hello"); // 힙에 "Hello" 저장
    let s2 = s1.clone();                   // 힙 데이터 복제
    println!("s1: {}, s2: {}", s1, s2);    // s1: Hello, s2: Hello
}
```
- String의 구조:
	- 스택: 포인터(힙 주소를 가리킴), 길이(len), 용량(capacity).
	- 힙: 실제 문자열 데이터("Hello"의 바이트 배열).
- s1.clone(): 힙에 있는 "Hello"를 새로 복제해 s2에 할당.

#### 힙 메모리에 저장되는 구체적인 경우

1. String:
	- &str은 고정된 문자열 슬라이스(스택 또는 정적 메모리)지만, String은 동적으로 늘어날 수 있는 문자열이라 힙에 저장.
	- 예: String::from("Hello") → 힙에 "Hello" 저장.
2. `Vec<T>`:
	- 요소 개수가 런타임에 변할 수 있으므로 힙에 저장.
	- 예: vec!`[1, 2, 3]` → 힙에 `[1, 2, 3]` 저장.
3. 구조체 내부의 힙 데이터:
- name은 String이므로 힙에 데이터가 저장되고, age는 u32라 스택에 저장.
```rust
struct Person {
    name: String, // 힙에 저장
    age: u32,     // 스택에 저장
}
```

4. `Box<T>`:
	- 단일 값을 힙에 강제로 저장.
	- 예: let b = Box::new(42) → 힙에 42 저장.


### Clone과 힙 메모리 복제
- Clone은 힙 데이터를 복제할 때 특히 중요하다.
- 스택 데이터: Copy로 암묵적 복사 가능(예: i32).
- 힙 데이터: Clone으로 명시적 복제 필요(예: String).
	- s.clone() → 힙에 새 메모리 할당 후 데이터 복사.

예제: 힙 데이터 복제
- v1.clone(): 힙에 새로 메모리를 할당하고 [1, 2, 3]을 복사.
```rust
fn main() {
    let v1 = vec![1, 2, 3]; // 힙에 [1, 2, 3] 저장
    let v2 = v1.clone();    // 힙에 새 배열 [1, 2, 3] 복제
    println!("v1: {:?}, v2: {:?}", v1, v2);
}
```

대조: 스택 데이터
- Copy로 암묵적 복사 → 힙 할당 없음.
```rust
#[derive(Clone, Copy)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1; // Copy로 스택 복사
    println!("p1: {:?}, p2: {:?}", p1, p2);
}
```

### 요약
- 힙에 저장되는 경우: 동적 크기 데이터(String, Vec, Box) → Clone으로 힙 복제.
- 스택에 저장되는 경우: 고정 크기 데이터(i32, u32, 단순 구조체) → Copy로 스택 복사.
- 구조체: 필드에 따라 혼합 가능(스택: u32, 힙: String).

